import{G as m,K as x,T as G,M as I,a as P}from"./MNIST-BhAB_iSj.js";class R{constructor(t,e,n,i,a){this.params=t,this.tm=n,this.kr=i,this.batchSize=a,this.baseLr=e,this.currentLr=e}baseLr;currentLr;stepCount=0;schedule={type:"constant"};step(t){this.updateLearningRate();const e=t??this.batchSize;for(const n of this.params){if(!n.gradient)continue;const i=this.kr.scalarMul.run(n.gradient,-this.currentLr/e);this.kr.inplaceAdd.run(n,i)}this.stepCount++}updateLearningRate(){switch(this.schedule.type){case"constant":break;case"step":this.stepCount>0&&this.stepCount%this.schedule.everyNSteps===0&&(this.currentLr*=this.schedule.factor);break;case"exponential":this.currentLr=this.baseLr*Math.pow(this.schedule.decayRate,this.stepCount);break;case"cosine":const t=Math.min(this.stepCount/this.schedule.maxSteps,1);this.currentLr=this.schedule.minLr+.5*(this.baseLr-this.schedule.minLr)*(1+Math.cos(Math.PI*t));break}}zeroGrad(){for(const t of this.params)t.gradient&&this.tm.writeBufferF32(t.gradient.buffer,new Float32Array(t.gradient.size).fill(0))}getLearningRate(){return this.currentLr}setLearningRate(t){this.baseLr=t,this.currentLr=t}setSchedule(t){this.schedule=t,this.currentLr=this.baseLr}getStepCount(){return this.stepCount}resetStepCount(){this.stepCount=0,this.currentLr=this.baseLr}}function v(r,t,e){const n=new Set,i=[];function a(s){if(!(n.has(s)||!s.requiresGradient)){n.add(s);for(const o of s.parents??[])a(o);i.push(s)}}a(e);for(const s of i)s.gradient=void 0;e.gradient=r.scopedOnes(e.shape);for(let s=i.length-1;s>=0;s--){const o=i[s];if(!o.gradFn||!o.gradient)continue;const h=o.gradFn.backward(o.gradient);for(let u=0;u<(o.parents??[]).length;u++){const c=o.parents[u],l=h[u];!c.requiresGradient||l===null||(c.gradient===void 0&&(c.gradient=r.getTensorBuffer(`${c.name}_grad`,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,l.shape,new Float32Array(l.size).fill(0))),t.inplaceAdd.run(c.gradient,l))}}}class ${constructor(t,e,n,i,a,s,o=15,h=32){this.tm=t,this.kernelRegistry=e,this.mnist=n,this.datasource=i,this.onTrainingFinished=a,this.onUpdateData=s,this.epochs=o,this.batchSize=h,this.optimizer=new R(n.model.parameters(),.05,t,e,h)}optimizer;iterator=null;currentEpoch=0;state="idle";saveSnapshot=!1;async initialize(){this.currentEpoch=0;const t=Math.min(this.datasource.trainImagesCount,this.datasource.maxTrainSize),e=Math.ceil(t/this.batchSize);this.optimizer.setSchedule({type:"cosine",minLr:.001,maxSteps:e*this.epochs}),this.iterator=this.datasource.getTrainIterator(this.batchSize),await this.mnist.restart()}async snapshot(){if(this.saveSnapshot)for(const t of this.mnist.model.parameters()){const e=await this.tm.readBuffer(t.buffer,t.sizeInBytes()),n=new Blob([e],{type:"application/octet-stream"}),i=URL.createObjectURL(n),a=document.createElement("a");a.href=i,a.download=`model-${this.currentEpoch}-${t.name}.bin`,a.click(),URL.revokeObjectURL(i)}}finished(){return this.currentEpoch>=this.epochs}async sync(){await m.device.queue.onSubmittedWorkDone()}async trainBatch(t){this.optimizer.zeroGrad();const e=t.size,n=this.tm.getTensorBuffer("input",GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,[e,784],t.data),i=this.tm.getTensorBuffer("labels_onehot",GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,[e,10],t.labels);this.tm.beginScope("fwd");const a=this.mnist.model.forward(n,!0),s=this.kernelRegistry.crossEntropy.run(a,i);this.tm.beginScope("bwd"),v(this.tm,this.kernelRegistry,s),this.optimizer.step(e),await this.sync(),this.tm.flushDestroyQueue()}async trainStep(){if(!this.iterator)throw new Error("Cannot train step without initializing trainer");if(this.state==="cancelling"){this.state="cancelled",this.iterator=null;return}this.iterator.hasNext()?await this.trainBatch(this.iterator.next()):(this.iterator=this.datasource.getTrainIterator(this.batchSize),this.currentEpoch++,await this.snapshot()),this.finished()?(this.state="finished",this.onUpdateData(this.currentEpoch,this.epochs,this.iterator.getCurrentIndex(),this.iterator.getSize()),this.onTrainingFinished()):(this.onUpdateData(this.currentEpoch,this.epochs,this.iterator.getCurrentIndex(),this.iterator.getSize()),this.state==="training"&&requestAnimationFrame(this.trainStep.bind(this)))}startTraining(){this.state="training",requestAnimationFrame(()=>this.trainStep())}cancelTraining(){this.state==="training"&&(this.state="cancelling")}}class M{constructor(t,e,n,i,a,s,o,h=32){this.tm=t,this.kernelRegistry=e,this.mnist=n,this.datasource=i,this.onTestResult=a,this.onTestFinished=s,this.onWrongGuess=o,this.batchSize=h}state="idle";testCorrect=0;testTotal=0;iterator=null;startTesting(){if(this.state!=="idle")throw new Error("Cannot start testing while already running.");if(!this.iterator)throw new Error("Cannot start testing without initializing. Call initialize() first.");this.state="testing",this.testCorrect=0,this.testTotal=0,requestAnimationFrame(this.testStep.bind(this))}finished(){return this.iterator!==null&&!this.iterator.hasNext()}async testStep(){if(!this.iterator)throw new Error("Cannot test step without initializing tester");if(this.state==="cancelling"){this.state="cancelled",this.iterator=null;return}this.iterator.hasNext()?(await this.testBatch(this.iterator.next()),this.onTestResult(this.testCorrect,this.testTotal,this.iterator.getCurrentIndex(),this.iterator.getSize())):this.onTestFinished(this.testCorrect,this.testTotal),this.finished()?(this.state="finished",this.onTestFinished(this.testCorrect,this.testTotal)):this.state==="testing"&&requestAnimationFrame(this.testStep.bind(this))}async initialize(){this.testTotal=0,this.testCorrect=0,await this.datasource.load("data/mnist").catch(t=>{throw new Error("Failed to load data source: "+t)}),this.iterator=this.datasource.getTestIterator(this.batchSize)}async testBatch(t){const e=this.tm.getTensorBuffer("test_input",GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,[t.size,784],t.data);this.tm.beginScope("test");const n=this.mnist.model.forward(e,!1),i=this.kernelRegistry.softmax.run(n),a=await this.tm.readBuffer(i.buffer,i.sizeInBytes());for(let s=0;s<t.size;s++){let o=-1/0,h=0;for(let c=0;c<10;c++){const l=a[s*10+c];l>o&&(o=l,h=c)}let u=0;for(let c=0;c<10;c++)if(t.labels[s*10+c]>.5){u=c;break}if(this.testTotal++,h===u)this.testCorrect++;else{const c=this.testTotal-this.testCorrect;this.onWrongGuess(t.data.subarray(s*28*28,(s+1)*28*28),h,u,c)}}}cancelTesting(){this.state==="testing"&&(this.state="cancelling")}}await m.init();const g=new G(m.device),b=new x(m.device,g),T=new I(g,b);await T.readSnapshot();const C=new P;await C.load("data/mnist").catch(r=>{throw new Error("Failed to load data source: "+r)});const B=document.getElementById("timer");let f=null,w=0;function E(r){const t=Math.floor(r/6e4),e=Math.floor(r%6e4/1e3),n=r%1e3;return`${t.toString().padStart(2,"0")}:${e.toString().padStart(2,"0")}.${n.toString().padStart(3,"0")}`}function k(){w=performance.now(),f=window.setInterval(()=>{const r=performance.now()-w;B.textContent=E(Math.floor(r))},10)}function F(){if(f!==null){clearInterval(f),f=null;const r=performance.now()-w;B.textContent=E(Math.floor(r))}}async function O(r,t){const e=new $(g,b,T,C,()=>{F(),p.textContent="Done",requestAnimationFrame(()=>L.startTesting())},(n,i,a,s)=>{const o=document.getElementById("out"),h=`Epoch ${n}/${i} (${a}/${s})`;o!==null&&(o.innerHTML=h)},r,t);await e.initialize(),k(),e.startTraining()}const L=new M(g,b,T,C,(r,t,e,n)=>{const i=document.getElementById("outtest"),a=(r/t*100).toFixed(2),s=`Testing: ${e}/${n} - Accuracy: ${a}%`;i!==null&&(i.innerHTML=s)},(r,t)=>{const e=document.getElementById("outtest"),n=(r/t*100).toFixed(2),i=`Test complete: ${r}/${t} (${n}%)`;e!==null&&(e.innerHTML=i)},(r,t,e,n)=>{if(n>=100)return;const i=document.getElementById("errors-container");if(!i)return;const a=document.createElement("div");a.className="error-sample";const s=4,o=document.createElement("canvas");o.width=28*s,o.height=28*s,a.appendChild(o);const h=o.getContext("2d");if(!h)throw new Error("MNISTDatasource: failed to get 2d canvas context");for(let l=0;l<28;l++)for(let d=0;d<28;d++){const U=l*28+d,S=Math.floor(r[U]*255);h.fillStyle=`rgba(${S}, ${S}, ${S}, 1)`,h.fillRect(d*s,l*s,s,s)}const u=document.createElement("span");u.textContent=`Predicted: ${t}`,a.appendChild(u);const c=document.createElement("span");c.textContent=`Actual: ${e}`,a.appendChild(c),i.appendChild(a)});await L.initialize();const p=document.getElementById("start-btn"),y=document.getElementById("epochs-select"),z=document.getElementById("batchsize-select");p.addEventListener("click",async()=>{const r=parseInt(y.value,10),t=parseInt(z.value,10);p.disabled=!0,y.disabled=!0,z.disabled=!0,p.textContent="Training...",await O(r,t)});
